import { computed, defineComponent, nextTick, watch } from "vue";
import { useCollapseItem } from "./provide.mjs";
import { props } from "./props.mjs";
import { createNamespace } from "../utils/components.mjs";
import { isArray, call } from "@varlet/shared";
const { name, n } = createNamespace("collapse");
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue";
function __render__(_ctx, _cache) {
  return _openBlock(), _createElementBlock(
    "div",
    {
      class: _normalizeClass(_ctx.n())
    },
    [
      _renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
const __sfc__ = defineComponent({
  name,
  props,
  setup(props2) {
    const active = computed(() => props2.modelValue);
    const offset = computed(() => props2.offset);
    const divider = computed(() => props2.divider);
    const elevation = computed(() => props2.elevation);
    const { length, collapseItem, bindCollapseItem } = useCollapseItem();
    const collapseProvider = {
      active,
      offset,
      divider,
      elevation,
      updateItem
    };
    watch(
      () => length.value,
      () => nextTick().then(resize)
    );
    watch(
      () => props2.modelValue,
      () => nextTick().then(resize)
    );
    bindCollapseItem(collapseProvider);
    function checkValue() {
      if (!props2.accordion && !isArray(props2.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be an Array');
        return false;
      }
      if (props2.accordion && isArray(props2.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be a String or Number');
        return false;
      }
      return true;
    }
    function getValue(value, isExpand) {
      if (!checkValue())
        return null;
      if (isExpand)
        return props2.accordion ? value : [...props2.modelValue, value];
      return props2.accordion ? null : props2.modelValue.filter((name2) => name2 !== value);
    }
    function updateItem(value, isExpand) {
      const modelValue = getValue(value, isExpand);
      call(props2["onUpdate:modelValue"], modelValue);
      call(props2.onChange, modelValue);
    }
    function matchName() {
      if (props2.accordion) {
        return collapseItem.find(({ name: name2 }) => props2.modelValue === name2.value);
      }
      const filterItem = collapseItem.filter(({ name: name2 }) => {
        if (name2.value === void 0)
          return false;
        return props2.modelValue.includes(name2.value);
      });
      return filterItem.length ? filterItem : void 0;
    }
    function matchIndex() {
      if (props2.accordion) {
        return collapseItem.find(
          ({ index, name: name2 }) => name2.value === void 0 && props2.modelValue === index.value
        );
      }
      return collapseItem.filter(
        ({ index, name: name2 }) => name2.value === void 0 && props2.modelValue.includes(index.value)
      );
    }
    function resize() {
      if (!checkValue())
        return;
      const matchProviders = matchName() || matchIndex();
      if (props2.accordion && !matchProviders || !props2.accordion && !matchProviders.length) {
        collapseItem.forEach((provider) => {
          provider.init(props2.accordion, false);
        });
        return;
      }
      collapseItem.forEach((provider) => {
        const isShow = props2.accordion ? matchProviders === provider : matchProviders.includes(provider);
        provider.init(props2.accordion, isShow);
      });
    }
    return {
      divider,
      n
    };
  }
});
__sfc__.render = __render__;
var stdin_default = __sfc__;
export {
  stdin_default as default
};
